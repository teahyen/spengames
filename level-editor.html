<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë ˆë²¨ ì—ë””í„° - ì„ê³  ì„ê³  ëŒë¦¬ê³  ì„ê³ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #764ba2;
            margin-bottom: 20px;
            text-align: center;
        }

        .editor-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            color: #333;
        }

        input[type="number"], select {
            padding: 8px;
            border: 2px solid #764ba2;
            border-radius: 5px;
            font-size: 16px;
        }

        .editor-canvas {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        #editorCanvas {
            border: 3px solid #764ba2;
            border-radius: 10px;
            cursor: pointer;
            background: #fff;
        }

        .tool-palette {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .tool-btn {
            padding: 10px 20px;
            border: 2px solid #764ba2;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tool-btn:hover {
            background: #764ba2;
            color: white;
        }

        .tool-btn.active {
            background: #764ba2;
            color: white;
            font-weight: bold;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: white;
            color: #764ba2;
            border: 2px solid #764ba2;
        }

        .btn-secondary:hover {
            background: #764ba2;
            color: white;
        }

        #levelOutput {
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }

        .instructions {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .instructions h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ ë ˆë²¨ ì—ë””í„°</h1>
        
        <div class="instructions">
            <h3>ì‚¬ìš© ë°©ë²•</h3>
            <ul>
                <li><strong>ê·¸ë¦¬ë“œ í¬ê¸°:</strong> ë ˆë²¨ì˜ ê°€ë¡œ/ì„¸ë¡œ í¬ê¸°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ (3-6)</li>
                <li><strong>ë„êµ¬ ì„ íƒ:</strong> ì•„ë˜ ë„êµ¬ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒ í›„ ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì„¸ìš”</li>
                <li><strong>ë²½ ê·¸ë¦¬ê¸°:</strong> íƒ€ì¼ì„ í´ë¦­í•˜ì—¬ ê° ë°©í–¥ì˜ ë²½ì„ í† ê¸€í•©ë‹ˆë‹¤</li>
                <li><strong>ë‚´ë³´ë‚´ê¸°:</strong> ì™„ì„±ëœ ë ˆë²¨ì„ JSON í˜•ì‹ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤</li>
            </ul>
        </div>

        <div class="editor-controls">
            <div class="control-group">
                <label for="gridSize">ê·¸ë¦¬ë“œ í¬ê¸°:</label>
                <input type="number" id="gridSize" min="3" max="6" value="4">
            </div>
            <div class="control-group">
                <label for="levelId">ë ˆë²¨ ID:</label>
                <input type="number" id="levelId" min="1" max="100" value="61">
            </div>
            <div class="control-group">
                <label for="timeLimit">ì‹œê°„ ì œí•œ (ì´ˆ, 0=ì—†ìŒ):</label>
                <input type="number" id="timeLimit" min="0" max="300" value="0">
            </div>
            <div class="control-group">
                <label for="moveLimit">ì´ë™ ì œí•œ (0=ì—†ìŒ):</label>
                <input type="number" id="moveLimit" min="0" max="100" value="0">
            </div>
        </div>

        <div class="tool-palette">
            <button class="tool-btn active" data-tool="wall">ğŸ§± ë²½ í¸ì§‘</button>
            <button class="tool-btn" data-tool="start">ğŸŸ¡ ì‹œì‘ì </button>
            <button class="tool-btn" data-tool="goal">ğŸŸ  ëª©í‘œì </button>
            <button class="tool-btn" data-tool="obstacle">ğŸ”´ ì¥ì• ë¬¼</button>
            <button class="tool-btn" data-tool="powerup-time">â° ì‹œê°„ íŒŒì›Œì—…</button>
            <button class="tool-btn" data-tool="powerup-teleport">âš¡ í…”ë ˆí¬íŠ¸</button>
            <button class="tool-btn" data-tool="powerup-remove">ğŸ’¥ ì¥ì• ë¬¼ ì œê±°</button>
        </div>

        <div class="editor-canvas">
            <canvas id="editorCanvas" width="600" height="600"></canvas>
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" onclick="clearLevel()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            <button class="btn btn-primary" onclick="exportLevel()">ğŸ’¾ ë ˆë²¨ ë‚´ë³´ë‚´ê¸°</button>
            <button class="btn btn-secondary" onclick="testLevel()">â–¶ï¸ ë ˆë²¨ í…ŒìŠ¤íŠ¸</button>
        </div>

        <div id="levelOutput"></div>
    </div>

    <script>
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        
        let gridSize = 4;
        let tileSize = 0;
        let currentTool = 'wall';
        let levelData = {
            start: { x: 0, y: 0 },
            goal: { x: 3, y: 3 },
            tiles: [],
            obstacles: [],
            powerups: []
        };

        // Initialize
        document.getElementById('gridSize').addEventListener('change', (e) => {
            gridSize = parseInt(e.target.value);
            initLevel();
        });

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentTool = e.target.dataset.tool;
            });
        });

        canvas.addEventListener('click', handleCanvasClick);

        function initLevel() {
            tileSize = canvas.width / gridSize;
            levelData.tiles = [];
            levelData.obstacles = [];
            levelData.powerups = [];
            levelData.goal = { x: gridSize - 1, y: gridSize - 1 };
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    levelData.tiles.push({
                        x: x,
                        y: y,
                        paths: ['N', 'E', 'S', 'W']
                    });
                }
            }
            
            render();
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            const tileX = Math.floor(clickX / tileSize);
            const tileY = Math.floor(clickY / tileSize);
            
            if (tileX < 0 || tileX >= gridSize || tileY < 0 || tileY >= gridSize) return;
            
            switch (currentTool) {
                case 'wall':
                    handleWallClick(tileX, tileY, clickX % tileSize, clickY % tileSize);
                    break;
                case 'start':
                    levelData.start = { x: tileX, y: tileY };
                    break;
                case 'goal':
                    levelData.goal = { x: tileX, y: tileY };
                    break;
                case 'obstacle':
                    toggleObstacle(tileX, tileY);
                    break;
                case 'powerup-time':
                    togglePowerup(tileX, tileY, 'extra_time');
                    break;
                case 'powerup-teleport':
                    togglePowerup(tileX, tileY, 'teleport');
                    break;
                case 'powerup-remove':
                    togglePowerup(tileX, tileY, 'remove_obstacle');
                    break;
            }
            
            render();
        }

        function handleWallClick(tileX, tileY, localX, localY) {
            const tile = levelData.tiles.find(t => t.x === tileX && t.y === tileY);
            if (!tile) return;
            
            const threshold = tileSize * 0.2;
            
            if (localY < threshold) {
                togglePath(tile, 'N');
            } else if (localY > tileSize - threshold) {
                togglePath(tile, 'S');
            } else if (localX < threshold) {
                togglePath(tile, 'W');
            } else if (localX > tileSize - threshold) {
                togglePath(tile, 'E');
            }
        }

        function togglePath(tile, direction) {
            const index = tile.paths.indexOf(direction);
            if (index > -1) {
                tile.paths.splice(index, 1);
            } else {
                tile.paths.push(direction);
            }
        }

        function toggleObstacle(x, y) {
            const index = levelData.obstacles.findIndex(o => o.x === x && o.y === y);
            if (index > -1) {
                levelData.obstacles.splice(index, 1);
            } else {
                levelData.obstacles.push({ x, y });
            }
        }

        function togglePowerup(x, y, type) {
            const index = levelData.powerups.findIndex(p => p.x === x && p.y === y);
            if (index > -1) {
                levelData.powerups.splice(index, 1);
            } else {
                levelData.powerups.push({ x, y, type });
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw tiles
            for (const tile of levelData.tiles) {
                const x = tile.x * tileSize;
                const y = tile.y * tileSize;
                
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(x, y, tileSize, tileSize);
                
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileSize, tileSize);
                
                // Draw walls
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                
                if (!tile.paths.includes('N')) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + tileSize, y);
                    ctx.stroke();
                }
                if (!tile.paths.includes('S')) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + tileSize);
                    ctx.lineTo(x + tileSize, y + tileSize);
                    ctx.stroke();
                }
                if (!tile.paths.includes('W')) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + tileSize);
                    ctx.stroke();
                }
                if (!tile.paths.includes('E')) {
                    ctx.beginPath();
                    ctx.moveTo(x + tileSize, y);
                    ctx.lineTo(x + tileSize, y + tileSize);
                    ctx.stroke();
                }
            }
            
            // Draw start
            drawCircle(levelData.start.x, levelData.start.y, '#ffeb3b', 'ğŸ');
            
            // Draw goal
            drawCircle(levelData.goal.x, levelData.goal.y, '#ff9500', 'ğŸ¯');
            
            // Draw obstacles
            for (const obstacle of levelData.obstacles) {
                drawCircle(obstacle.x, obstacle.y, '#e74c3c', 'â­•');
            }
            
            // Draw powerups
            for (const powerup of levelData.powerups) {
                let color = '#3498db';
                let emoji = 'âš¡';
                if (powerup.type === 'extra_time') {
                    color = '#2ecc71';
                    emoji = 'â°';
                } else if (powerup.type === 'teleport') {
                    color = '#9b59b6';
                    emoji = 'ğŸ’«';
                } else if (powerup.type === 'remove_obstacle') {
                    color = '#f39c12';
                    emoji = 'ğŸ’¥';
                }
                drawCircle(powerup.x, powerup.y, color, emoji);
            }
        }

        function drawCircle(tileX, tileY, color, emoji) {
            const x = tileX * tileSize + tileSize / 2;
            const y = tileY * tileSize + tileSize / 2;
            const radius = tileSize * 0.3;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.font = `${tileSize * 0.4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, x, y);
        }

        function clearLevel() {
            initLevel();
        }

        function exportLevel() {
            const levelId = parseInt(document.getElementById('levelId').value);
            const timeLimit = parseInt(document.getElementById('timeLimit').value);
            const moveLimit = parseInt(document.getElementById('moveLimit').value);
            
            const level = {
                id: levelId,
                size: gridSize,
                start: levelData.start,
                goal: levelData.goal,
                tiles: levelData.tiles,
                obstacles: levelData.obstacles.length > 0 ? levelData.obstacles : undefined,
                powerups: levelData.powerups.length > 0 ? levelData.powerups : undefined,
                timeLimit: timeLimit > 0 ? timeLimit : undefined,
                moveLimit: moveLimit > 0 ? moveLimit : undefined
            };
            
            // Clean up undefined properties
            Object.keys(level).forEach(key => level[key] === undefined && delete level[key]);
            
            const output = JSON.stringify(level, null, 2);
            document.getElementById('levelOutput').textContent = output;
            
            // Copy to clipboard
            navigator.clipboard.writeText(output).then(() => {
                alert('ë ˆë²¨ ë°ì´í„°ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }

        function testLevel() {
            const levelId = parseInt(document.getElementById('levelId').value);
            alert('ë ˆë²¨ í…ŒìŠ¤íŠ¸ ê¸°ëŠ¥ì€ ë©”ì¸ ê²Œì„ì—ì„œ êµ¬í˜„ë©ë‹ˆë‹¤.\në ˆë²¨ ë°ì´í„°ë¥¼ ë‚´ë³´ë‚´ê¸°í•˜ì—¬ levels.jsì— ì¶”ê°€í•˜ì„¸ìš”.');
        }

        // Initialize on load
        initLevel();
    </script>
</body>
</html>
